class Solution:
    def rob(self, nums: List[int]) -> int:
        '''
        현재까지 털었을 때, 가장 많이 털수 있는 금액
        단, 붙어있는 집을 연달아서 털면 잡히므로 그러면 안됨.
        짝수로만 하는 경우
        홀수로만 하는 경우
        중간에 두 칸을 건너뛰는 경우
        세 칸을 건너뛰는 경우가 존재할 수 있는가?
        => 손해일 것으로 판단되지만 가능한가? X
        ==> 두 칸만 연달아서 가지 않으면 되니까 세 칸을 건너뛰는 것은 손해임
        1  1  1  1  1
        ㅇ    ㅇ    ㅇ
          ㅇ     ㅇ
        1  1  1  4  2
        ㅇ       ㅇ 
        '''
        '''
        점화식을 세운다면? 
        1개 일 때,
        첫번째 것
        2개 일 때,
        첫 번째 혹은 두 번째 것
        3개 일 때,
        첫 번째 && 세 번째 혹은 
        두 번째 것
        4개 일 때,
        첫 번째 && 세 번째 혹은
        첫 번째 && 네 번째 혹은
        두 번째 && 네 번째 
        5개 일때,
        첫 번째 && 세 번째 && 다섯 번째 혹은
        첫 번째 && 네 번째 혹은
        두 번째 && 네 번째 혹은
        두 번째 && 다섯 번째 혹은
        f(1), f(4)
        f(1), f(3)
        f(2), f(4)

        (n >= 4)
        dp[n] = max(dp[n-3] + dp[n], dp[n-1] + dp[n-3], dp[n-2] + dp[n])
        '''
        nums_len = len(nums)
        dp = [0] + [ nums[idx] for idx in range(nums_len)]
        # 3개 일 때까지 노가다
        # 1개 일 때,
        # 첫번째 것
        # 2개 일 때,
        # 첫 번째 혹은 두 번째 것
        # 3개 일 때,
        # 첫 번째 && 세 번째 혹은 
        # 두 번째 것
        
        if len(dp) > 2:
            dp[2] = max(dp[1], dp[2])
        if len(dp) > 3:
            dp[3] = max(dp[1] + dp[3], dp[2])

        # 4개 이상
        for n in range(4, nums_len + 1):
            dp[n] = max(dp[n-3] + dp[n], dp[n-2] + dp[n])
        return max(dp)
