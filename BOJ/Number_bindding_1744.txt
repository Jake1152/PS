#1744_수 묶기 17DEC20 pm 4:40
Total 2:53
-이해 6"50
-해결방법 15"00 + 3"00(readline 검색)
 +30"(양수만 들어온 경우 감안 안됨)
 
-손코딩 41"00
-구현 24"00 + 21"00
-실행되는지 눈으로 확인 
  9"00 오류발견
-디버깅  32"00 (양수 중 1인 경우는 곱하지말고 더하는게 더 나음)
 (음수, 0 덧셈 곱셈 논리 수정 필요)
 0의 개수와 음수,0의 개수의 합이 홀수인지 판별하고 서로 곱한 뒤 더하는 부분처리
 
 
13분부터

문제
길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 
하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 
수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 
위치에 상관없이 묶을 수 있다. 
하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 
그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.

예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 
하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2*3)+(4*5) = 27이 되어 최대가 된다.

수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.

수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.

입력
첫째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작은 자연수이다. 
둘째 줄부터 N개의 줄에, 수열의 각 수가 주어진다. 
수열의 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.

출력
수를 합이 최대가 나오게 묶었을 때 합을 출력한다. 정답은 항상 231보다 작다.

#문제이해
수열의 합에서 그냥 더하는 것이 아니라 짝지어서 묶을 수 있으면 
묶는 수들은 서로 곱한다.
최대 묶을 수 개수는 2개이다
수의 범위는 -10,000 <= N <= 10,000
묶는게 이득이 아니면 그냥 더한다.
수열의 합이 최대가 되도록만들어서 값을 return


수열의 합 
쌍으로 묶어서 서로 곱한 뒤에 더하기
총합이 최대가 되도록한다.


#문제해결방법
음수는 서로 곱하는게 낫다. 서로 큰 수끼리 곱할수록 이득이다.
음수가 홀수 개이면서 0이 있다면 가장 작은 수를 0과 곱하거나 
0이 없다면 그냥 전체 합에 더해버린다.

만약 가장 작은 음수를 다른 양수와 곱하는게 더 나을 수 있는가?X

오름차순이든 내림차순이든 하나의 기준으로 정렬한다.
오름차순으로 정렬한 뒤에
0이하와 양수로 배열을 나눈다.(인덱스로 구분)
왼쪽이 0이하이면서 오른쪽이 양수인 인덱스

음수,0 배열은 
순서대로 2개씩 묶어서 곱한 다음에 sum 변수에 더 한다.
마지막이 1개이면(음수 1개이거나 0) 그냥 sum변수에 더한다.

양수배열은 배열 끝에서부터 순회한다.
순서대로 2개씩 묶어서 곱한뒤 sum변수에 더한다.
마지막 1개(해당 배열에서 가장 작은 양수)는 그냥 sum 변수에 더 한다.

어떻게 0이하인지 구분할 것인가?
이진탐색?
(왼쪽이 0이하이면서 오른쪽이 양수인 인덱스)

어떻게 마지막이 쌍이 안되고 1개인지 구분할 것인가?
짝수개이면 순서대로 곱하고
홀수개이면 미리 마지막 순회할 숫자를 
sum에 더한다.
순회는 마지막 직전까지하면서 묶어서 곱한 뒤 더한다.

전체 배열 길이를 알아야함
음의 부분 끝 위치(인덱스)를 알아야함


- 입력받는 N개의 수를 배열에 추가한다.
- 해당배열을 내림차순으로 정렬한다.
- 0이하인 부분의 인덱스를 알아낸다.
- 0이하인 부분이 홀수개인지 짝수개인지 판별한 뒤
 묶어서 더하는 연산을 진행한다.

- 양수 부분이 홀수개인지 짝수개인지 판별한 뒤
 배열 끝에서부터 양수 시작 위치까지 역순으로 2개씩 묶어서 더하는 연산을 진행한다.
 
  - 0또는 음수만 들어온 경우
  - 양수만 들어온 경우
  - 둘다 들어온 경우 

3가지 경우에 반복문을 어떻게 돌릴 것 인가?

all 양수, all 음수, 둘다 3가지 경우에 대해 반복문은 2개까지만 돌리고싶다
0+음수, 양수

반복문1" 음수 가장 작은 수부터 0까지 순회
반복문2" 양수 가장 큰 수부터 가장 작은 수까지 역순으로 순회

반복문1,2가 같이 도는 경우는 양수, 음수 둘다 들어왔을때만



20DEC20 PM 6:40
0, 음수, 양수

같은 양수, 음수끼리는 절대값이 가장 큰 두 값을 곱하는게 
두 수를 곱한 결과를 크게 만든다.

그래서 오름차순 정렬을 하고
양수 시작위치를 기준으로 
양수만 들어온 경우 
0,음수만 들어온 경우 
둘다 들어온 경우로 나누어서 
끼리끼리 곱해서 최대값이 나오도록 했다 

40퍼대에서 실패가 떴다
어떤 부분에서 문제인가?
0과 음수를 곱하는 부분?

음수가 짝수개 있으면 곱하는게 낫다
음수가 홀수개 있고 0이 1개 이상 있으면 
0과 음수를 곱한다.

0,음수 개수가 홀수개 일때 
절대값이 가장 작은 1개는 그냥 더하게했다(음수이건 0이건)
나머지는 절대값이 큰 순서부터 곱하게 했다.
그런데 오류가 발생한다
어떤 부분이 문제인가?

-5 -4 -3 -2 -1 0
-5 -4 -3 -2 0 0
-5 -4 -3 0 0 0

0 또는 음수가 홀수개인지는 구분해서 계산할 필요가없다.
0,음수 같은 묶음으로 보고 계산해도 결과가 맞다.
문제를 잘못 이해했는가?

1을 곱한 경우도 별도로 처리했다.
짝수개이면 그대로 곱하게하고 
1의 개수만큼 
결과값에 더하게 했다.
X

착각
1 * 1 =1
마지막에 1의 개수만큼 더하면 실제 예상 값보다 더 크게 나온다

1* n (n>=2) 일때만 1개수만큼 빼는게 의미가 있다.

양수가 짝수일떄
1인 개수가 1개
2개이상

양수가 홀수일떄


#실행
1끼리 곱하는 경우를 빼놓아서 디버깅에 시간 소요


#회고
처음부터 >1,1,1< 나누었다면 시간소요가 덜 들었을텐데
왜인지 그게 더 번잡하다 느껴
그냥 다 받고서 중간에 어디부터 양수인지 확인하는 루틴을 넣어서 확인하게 했다.
하지만 1일 경우를 파악해야하는 조건문이 들어가야하는 부분 등이 비효율적이라
결과적으로 시간 소요가 더 되었다.

처음부터 1을 기준으로 나누는게 더 빠르고 깔끔하게 구조를 나눌 수 있었다.

- 처음 문제해결방법 결정 전제부터 다시 살펴본다.
그 전제가 과연 맞는지 ex) 처음부터 0&음수,양수로 나누는거보다 다 받고 후에 기준점을 찾는방식

- 고려사항들이 다 맞는지 방법을 계획하기 전에 확인할 것
1끼리 곱하는 경우를 생각지 못해서 
중간에 다시 프로그램을 바꿔야해서 구조가 깔끔해지지 못했다.
처음부터 여러 경우의 수를 제대로 고려했다면 
그에 알맞는 프로그램 구조를 만들기에 수월 했을 것이다.
 -문제재정의 및 갖은 경우의 수 일반적인 케이스, 경계값 등 문제가 될수 있는 케이스 감안














