1로 만들기 20DEC20 AM 12:26
-이해 3"00
-방법계획 20"00  + 2"00

다른이 풀이 참조
이해 20" 손코딩 10", 정리 20"
-검증  
-손코딩 
-구현


#문제이해
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

입력
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.


#문제 재정의
3가지 연산을 적절히 사용해서 최소횟수로 1로 만든다.
1. 3으로 나누어지면 나눈다
2. 2로 나누어지면 나눈다.
3. 1을 뺸다

적절히 사용하는게 포인트
어떤게 적절한가
적절한 케이스들을 계산한다?
그냥 매순간 가능한 케이스를 메모하며 쭉이어간다?
각 경로별 결과들의 최소값을 반환?


#해결방법계획

3으로 나누거나 2로 나누었을떄 어떤게 이득인가?
3,2의 공배수라면? 6의 배수 

6
6/3 ->2, 2/2->1
6
6/2 ->3, 3/3->1

36
36/3->12, 12/3->4, 4/2->2, 2/2->1  4회
36/2->18, 18/3->6, 6/3->2, 2/2->1  4회
36/2->18, 18/2->9, 9/3->3, 3/3->1  4회

37
37-1->36

40
40-1->39, 39/3->13, 13-1->12, 12/3->4, 4/2->2, 2/2->1
40/2->20, 20/2->10, 10/2->5, 5-1->4, 4/2->2, 2/2->1

순서대로하면 그대로 일거 같다.
그런데 항상 그런지는 어떻게 알것인가?
2로 먼저나누나 3으로 나누나 테스트해본 케이스들에서는 1로만들기까지의 횟수의 차이가 없다.

왜 DP일까
구조의 부분을 파악
구조를 재귀적으로 표현
재귀의 중복부분을 중복되지 않게 조정
부분 해의 합은 전체의 해가 된다.

주어진 숫자 3으로 나누거나 2로 나누거나 1로 빼면 
최소횟수로 다다를거 같은데 왜 DP인가 
먼저 빼보고 3으로 나누거나 2루나누거나
만약 소수를 빼본다면?


111
111-1->110, 110/2->55, 55-1->54, 54/2->27, 27/3->9, 9/3->3, 3/3->1
111-1->110, 110-1->109, 109/3->33, 33/3->11, 11-1->10, 10/2->5, 5-1->4, 4/2->2, 2/2->1


46 ------ 발견
46/2->23, 23-1->22, 22/2->11, 11-1->10, 10/2->5, 5-1->4, 4/2->2, 2/2->1
46-1->45, 45/3->15, 15/3->5, 5-1->4, 4/2->2, 2/2->1


중간에 소수가 등장하면 연산이 느려진다. 
소수가오는 경우를 줄이면 도움된다.
소수가 아니더라도 2또는 3의 배수인 수가 많을수록 빠르게 연산이 가능하다.
그렇다면?
주어진 수를 소인수분해 한다음에 2,3의 배수가 되도록 1을 이용해서 조정해보는 경우를 본다?
오래걸릴거 같다.

그냥 3가지를 로테이션하면서 끝까지 계산하고 그 결과들의 최소값을 반환하게 한다?
3가지 로테이션이 의미 있는가?
3가지 로테이션할때 각 과정을 기록한다.
3가지 로테이션을 각 과정마다 다르게 해야하나?
3가지 방법을 a,b,c라고 했을떄 

46을 1로 만드는 방법을 구할때
46에서 가능한 수를 계산해본다.
처음에 b,c가 가능 
46 = b->c->b->c->b->c->b->b (마지막은 1로 빼기만해도 결과가 같긴하다.)
46 = c->a->a->c->b->b (마지막은 1로 빼기만해도 결과가 같긴하다.)

각 단계별로 가능한 경우별로 쭉 진행한다.
이전 경로를 기록한다?
어떻게해야 중복을 피할 수 있는가?

이전과 같은 과정인가?

이전경로를 별도 배열에 추가한다
거쳐온 경로가 배열안에 없으면 추가하고 진행하며 있으면 멈춘다.
단 이 조건이라면 순환을 써야한다.

어떻게 전체 경우의 수를 알 수 있을까?
순환을 안쓰고 어떻게 표현할 수 있을까?
전체 경우 수를 몰라도 반복문으로 표현할 수는 없을까?

순환을 쓰면 1로 빼는 경우만 반복할 경우 오래 걸리므로 
순환조건에 a,b,c로 순서로만 계산했을때 개수보다 오래걸리면 멈추게하는 조건을 넣는다.
아니면 미리 계산을 하지 말고 
1을 빼는 경우는 2,3으로 나눌 수 없는 경우에만 하게 만들고
2,3 둘다로 나눌수 있는 경우는 두 방법으로 진행해본다.

조건은 1이 될때까지

12의 경우 2로 나누기 시작하는게 연산 횟수를 줄일 수 있다.

모든 경우의 수는 어떻게 아는가?
2로 나누었을때 결과?
3으로 나누었을떄 결과?


#검증
전체경우의 수 파악 실패 다른이의 풀이 참조


#실행
다른이 풀이1
bottom up
들어온 숫자의 크기만큼 배열생성
3으로 나누었을때
2로 나누었을때 등으로 현재까지 1로 만드는데 든 소요된 횟수가 작은 수를 
result 배열에 넣게하여

마지막에는 모든 경우의 수를 거친 최소값이 남게된다.

다른이 풀이2
top down
재귀를 이용 
초기에 {1:0, 2:1}과 같은 dictionary를 사용
1로 만들기라 1이면 더 이상 별도의 작업 필요 없으므로 0
2이면 1로 만드는데 1을 빼거나 2로 나누거나 하면 되는데 모두 1번만 소요되므로 1

그 이외에 숫자에서 1로 만들까지 최소횟수는 어떤 숫자가 들어오느냐에따라 다르므로
그때 그떄 연산하여 처리되도록함 
들어온 수 n이 dictionary에 있으면 그 값을 return
없으면 
m = 1 + min(routine(n//2)+n%2, routine(n//3)+n%3)
memo[n] = m
과 같이 
2로 나눈 몫을 재귀하고 그 나머지를 더함,
3로 나눈 몫을 재귀하고 그 나머지를 더함

두 과정 중 소요되는 회수가 더 적은 과정을 선택하고 
+1을 한다.
+1을 해야 몇번 소요되었는지 값을 더해가면서 계산이 가능한다.
이미 2,3 둘 중에 최소횟수인 것을 선택했으므로 최소인것은 분명하다.

이 과정을 n값이 구해질떄까지 재귀를 통해 반복된다.
12였으면 
12,6,3,1,1(3을 3으로 나눔), 2(6을 3으로 나눔), 4(12를 3으로 나눔), 2(4를 2로 나눔), 1
의 과정을 거친다.
12에서부터 나누어서 베이스케이스(1,2)에 도달하면 값들이 리턴되고 
리턴된값에 몇회 소요되었는지 나머지 값과 +1이 되어서 
결국 알고자 했던 n(이 예시에서는 12)이 최소 몇회 걸려서 1로 만들 수 있는지
알 수 있게된다.


#회고
전체경우의 수를 세우지 못한 점
재귀를 좀더 생각할 것 
어떻게 부분으로 쪼개고 base case는 어떻게할지 생각할

문제를 이해하는 것과 지문대로 푸는 것은 다른 것!
이 문제에서는 굳이 1씩 빼는 루틴을 넣을 필요없이 2,3으로 나누었을때의 나머지로 계산했다.

문제를 정확히 이해하되
지문에 서술된 과정으로 문제를 해결할 필요는 없다.

문제를 다르게도 정의해볼 것이며
(명제, 대우 이용)

어떻게하면 과정을 단순화할지 더 생각한다.




