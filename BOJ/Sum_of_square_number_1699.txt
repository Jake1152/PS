#제곱수의 합 18DEC20 AM 1:16
-이해 3"00
-해결방법 6"00
-손코딩 2"30
-구현 15"00
-디버깅 25"00
45"

문제
어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 
예를 들어 11=32+12+12(3개 항)이다. 
이런 표현방법은 여러 가지가 될 수 있는데, 
11의 경우 11=22+22+12+12+12(5개 항)도 가능하다. 
이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 
또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 
11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.

주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)

출력
주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.

#문제이해
주어진 N을 제곱수들의 합으로 표현한다.
제곱수를 가장 적게 쓰는 개수를 출력한다.

제곱수들의 합으로 표현할때 그 항의 최소개수

N보다 작거나 같은 제곱수들의 합
작거나 같다.
12의 경우 가능한 가장 제곱수를 먼저 빼고 나머지를 제곱수로 표현할때 4회의 연산이 필요하다
3^2, 1^2, 1^2, 1^2
하지만 2^2 4로만 표현하면
2^2, 2^2, 2^2 3개로 표현 가능하다.

어떻게할때 최소 횟수를 만족할 수 있는가?

모든 경우란? 
1^2, 2^2
최대 10만이니
10^(2.5)
300여개

1부터 300까지 제곱수의 합으로 표현하면 몇개를 그렇게 표현할 수 있는지
계산하고서 최소횟수를 반환?
그러면 최대 300여개의 공간이 필요하다.

굳이 공간을 많이 만들기 싫다면?
순환으로 푼다.
'1로만들기'를 참고할 수 있는가?

N으로 표현하기 위해 필요한 제곱수 
전체 경우의 수
부분 해의 합이 전체의 해가 되는 방법


base case, 어떻게 base case에 도달하게 할건지
어떻게 문제를 쪼개서 해결할건지
쪼개서 해결한 것(부분해)를 저장하는데 
그것을 이용해서 어떻게 중복이 발생하지 않도록 만들것인지


13
3,2

14
3, 1, 2
2, 3, 1

n제곱수가 아닌경우 
n가 가까운 작은 제곱수의로 뺀 경우 
남는 수가 제곱수도 짝수도 아니면 과정이 더 늘어남

나보다 작은 정수의 제곱수, 나보다 큰 정수의 제곱수하고 간격이 멀면 과정이 들어난다 
ex)

3^2<13<4^2
12.5

1771
42, 2, 1, 1, 1
41, 9, 3
40, 13, 1, 1
39, 15, 5

제곱수로 이루어진 최소횟수

N이 제곱수 1개로 표현이 안될때 
N보다 작은 제곱수부터 시작하여 1씩 줄인다.

1771
42^2->1^2의 합으로 표현?
중간에 현재까지 나온 최소횟수보다 길면 스킵한다.
하지만 중간값을 표현하는 경우가 여러개라면?

각 숫자별로 제곱수의 합으로 표현할 수 있는 최소횟수를 입력
각 숫자별로 제곱수의 합은 어떻게 표현할 수 있는가?
각 숫자별로 제곱수의 합 표현의 끝이 어디인지 어떻게 알 것인가?
재귀식으로는 어떻게 그것을 표현할 것인가?

배열에 각 수별 최소횟수 기록
배열로 생성?
아니면 dict?
둘다 만든 다음에 비교?
최소값을 담는 별도의 전역변수 사용?
dict으로 만든 다음 각 숫자별로 제곱수의 합으로 표현될 수 있는 최소 횟수를 기록 


제곱수로 표현에서 중간에 이미 다른 수의 최소횟수를 넘어서면 
거기서 멈추고 다음 연산을 하게 만든다
순환에서 break
1771에서 가장 가까운 제곱수의 제곱근은 42
25의 제곱과 다른 

42부터 29까지

1771/2 => 885
가까운 제곱수는 29 (841)

중간에 호출되는 숫자별로 제곱수로 표현할 수 있는
최소 횟수를 메모한다.


#문제해결방법
DP와 연관은?
재귀식인데 중복있는 경우의 처리
어떤 중복이 있는가?
N과 가까운 제곱수를 찾는다.

N의 제곱근을 구한다.
제곱근을 정수로 만든 뒤(소수점 버림) 제곱한다.
N에서 제곱한 수를 뺀다.
다시 그 수의 제곱근을 구한다.

11
3
2
1

0보다 큰 동안 제곱근으로 만들고 정수로 만들고 
N에서 빼고 
남은 수를 다시 제곱근,정수, 원 값에서 빼기를 반복
1회 반복마다 count +1

N**0.5를 구한다


10을 구성하는 제곱수의 합 경우의 수 및 최소횟수
10 = 3^2 + 1^2
10 = 2^2 + 2^2 + 1^2 + 1^2

int((10//2 ) ** 0.5 ) = 2

3에서 2까지 1씩 감소하면서 반복 
n에 가까운 제곱수의 제곱근부터, n/2에 가까운 제곱수의 제곱근까지 반복하여 
n을 구성하는 경우의 수를 모두 확인한다.
그 중에 제일 횟수가 적은게 n의 제곱수의 합의 횟수가 최소가 되는 수이다.
그런데 이미 혹은 for문 중간에 최소인가 밝혀지면 어떻게 처리?
증가는 어떻게 시킬것인가?


#실행
여러번의 수정 끝에 성공
memo라는 dict으로 이미 계산한 숫자의 제곱수 합 최소 횟수를 기록
memo에 있는지 확인
있으면 return memo[n]

없으면 square root를 구성하는 경우들 중에 최소횟수를 찾는다.

a. n보다 작으면 가장 가까운 square_root를 구한다.
  그 값을 min_square로 넣음
b. (n보다 작으면 가장 가까운 square_root) -1
   한 값을 start에 저장
c. n의 절반 값의 square_root를 구한다.

d. for문으로 a,b 까지 -1씩 변화하면서 반복한다.

min_square와 for문에서 각 경우(n을 만들기 위한 제곱수 합울 만드는 경우)의 횟수와 비교한다.
min_square가 for문 속 각 경우보다 크면 
for 문 속 각 경우를 min_square로 갱신한다.

e. for문이 끝나고 나온 min_square 값을 memo[n]에 넣는다.
  return min_square 하고 끝


#회고
더 빠른 방법, 단순한 방법 필요

- 점화식을 더 빨리 세울 것
컴퓨터에 메모하지말고 종이에 과정을 차근히 적는게 더 빠르고 확실하다.


