#암호코드 2011 27DEC20 PM 11:22
-이해 7"10
-방법계획 30"0 + 
-검증
-손코딩
-구현



문제
상근이와 선영이가 다른 사람들이 남매간의 대화를 듣는 것을 방지하기 위해서 대화를 서로 암호화 하기로 했다. 그래서 다음과 같은 대화를 했다.

상근: 그냥 간단히 암호화 하자. A를 1이라고 하고, B는 2로, 그리고 Z는 26으로 하는거야.
선영: 그럼 안돼. 만약, "BEAN"을 암호화하면 25114가 나오는데, 
이걸 다시 글자로 바꾸는 방법은 여러 가지가 있어.
상근: 그렇네. 25114를 다시 영어로 바꾸면, 
"BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN" 총 6가지가 나오는데, BEAN이 맞는 단어라는건 쉽게 알수 있잖아?
선영: 예가 적절하지 않았네 ㅠㅠ 만약 내가 500자리 글자를 암호화 했다고 해봐. 그 때는 나올 수 있는 해석이 정말 많은데, 그걸 언제 다해봐?
상근: 얼마나 많은데?
선영: 구해보자!
어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 프로그램을 작성하시오.

입력
첫째 줄에 5000자리 이하의 암호가 주어진다. 암호는 숫자로 이루어져 있다.

출력
나올 수 있는 해석의 가짓수를 구하시오. 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.

암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 출력한다.


#문제이해
숫자열이 주어졌을때 
1~26을 알파벳으로 표현할 수 있다.
그때 주어진 숫자열로 표현할 수 있는 단어(암호의 해석)이 몇 개인지 구한다.
결과가 매우 많을 수 있으므로 1000000으로 나눈 나머지를 출력
암호가 잘못되어 암호를 해석할 수 있는 경우에는 0을 출력한다.


#문제 재정의
숫자를 암호로 표현한다.
표현하고자 하는 단어를 숫자로 만든 다음에 
해당 숫자들을 그대로 이어붙인다.
그랬을 때 나오는 숫자열이 몇가지의 단어로 해석될 수 있는지 출력


#해결방법
숫자들을 앞에서부터 뒤로가면서 
두 자리 일때 알파벳(1~26)으로 표현될 수 있는지 파악하고 
그렇게 표현해본다.
한 자리 일떄도 구한다.
하지만 두 자리 일떄 알파벳으로 표현될 수 없다면 1자리 알파벳으로만 표현될 수 있다.

표현 가능한 경우를 끊어서 확인?
끊어서 배열에 추가?
메모리 소요
배열에 추가해서 확인하지 않으면 
어떻게 이미 확인했는지 알것인가?
만ㅇ약 배열에 추가해서 있는지를 파악한다면
배열 원소 앞에서부터 뒤까지 비교하게된다.


251156423

25 11 15 23 은 2자리 알파벳으로 표현 가능하다.

25 11 5 6 4 23
25 1 15 6 4 23
2 5 1 1 5 6 4 2 3

7891
780123
7 8 0 12 3
7 8 0 1 23 
7 8 0 1 2 3 
7 8 0 1 

123
12 3
1 23
1 2 3

1234
12 3 4
1 23 4
1 2 3 4

1225
1 2 25
1 22 5
12 25
12 2 5
1 2 2 5


25114

25 11 4
25 1 1 4
25 1 14
2 5 11 4
2 5 1 14
2 5 1 1 4


22114

0~n-1

2
22 11 4
22 1 14
22 1 1 4
2 21 14
2 21 1 4
2 2 11 4
2 2 1 14
2 2 1 1 4

0이 있는 경우도 문제

- 다른이의 답
점화식
한자리일때 두자리일때 

dp[n] = dp[n] + dp[n-1]
dp[n] = dp[n] + dp[n-2]

for (int i = 1; i <= len; i++) { 
	if (array[i] != 0) { 
		dp[i] = (dp[i - 1] + dp[i]) % 1000000; 
	} 
	
	int x = array[i] + array[i - 1] * 10; 
	if (10 <= x && x <= 26) { 
		dp[i] = (dp[i - 2] + dp[i]) % 1000000; 
	} 
}

from sys import stdin

stdin.readline()




#검증


#실행


#회고



