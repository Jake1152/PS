감소하는 수 11AUG21 AM 03:06

#문제이해

952



앞자리숫자보다 뒷자리숫자가 더 작아야 감소하는 수이다
연속되는 앞자리랑 뒷자리 숫자가 같은 것은 치지 않는다.
1의 자릿수도 포함된다.
1 2 3 4 5 6
0번쨰 감소하는 수가 없다면 -1 return


#문제 재정의
감소하는 수
큰 자릿수보다 그 다음 자릿수 숫자는 작아야한다.
1의 자릿수도 포함된다.


#문제해결방법

그런데 N번쨰 감소하는 수가 없을 수 있는가?
너무커서 int범위를 넘어가는 것을 의미하는가?
9,223,372,036,854,775,807
900경? 
어떻게 구해야 효율적일것인가?
1의 자릿수부터 숫자를 증가시키면서 감소하는 수인지 확인?
감소하는 수의 특징
자릿수를 증가시키면서 확인한다.
맨 앞자릿수가 9 그 다음은 n-1 ... 0일때까지
n번째를 예측해야한다.
9부터 시작하지말고 
0123456789
10 11(x)
20 21 22(x)
30 31 32 33(x)
40 41 42 43
...
90 ... 98
100 (x)
210
310 320 321
재귀로는 어떻게 풀 수 있는가?
순서는 1의 자릿수부터 증가시켜가며 감소수열인지 확인한다.
감소수열이 아니라면 윗자릿수를 바꾼다?

prev = 10
for digit in "321":
	if prev > 3:

32
321

단순한 방법
10자릿수
1씩 증가
1,234,567,890
90억
90초 불가

다음 감소하는 수를 1씩 증가가 아니라
논리를 통해 바로 접근시키는 방법

1~9
10
큰 자릿수부터 작은 자릿수로 이동


---
1의 자릿수부터 시작하는 방법
다음 자릿수가 이전 자릿수보다 커야한다.
단점 전체자릿수가 몇이냐에 따라 
올수있는 숫자가 한정될 수 있다.

digits변수에 저장
digits = 1부터 시작

prev = 0
digit = 1
54321 % (10 ** (digit))

while (num // digit):
	if prev > digit:
		
	digit += 1


10 // 10 ** (0)

다음 감소하는 수를 어떻게 찾을 것인가?

10 20 21 22(x)
80 81 ... 87 88(x)
90
90 91 ... 98 99(x)

- 210
  더이상 200자리에서는 감소하는 숫자가 나올 수 없다.
  다음 자릿수로 이동
  num + (10**2)
 
- 310
  num + (10**2)해서 나온 결과
  3, 1, 0 감소하는 수 
  그 다음 감소하는 수 
  1의 자릿수 변경?
  311
  감소하는 수가 아님
  감소하는 수가 아닌것을 직접 확인하기 
  이전에 알 수 있는 방법은?
  310 다음의 감소하는 수
  320
  
  4210
  4320
  4321

  3보다 작은 수가
  맨 앞자리 3
  dfs
  - 숫자 9
  - 0~8
  - 0~7
  
  자릿수마다
  
prev_digit
prev_num

- 311
문자열로 안바꾸고 10**n, 10의 몇 n 제곱 자리인지 알고자 한다면
처음에 몇 자릿수인지 확인해야한다.
작은 자릿수부터 확인해 나아가면 그렇지 않아도 된다.
작은 자릿수부터 읽을 것인가
큰 자릿수부터 
  prev_digit
  prev_num

320 321 322
330
  
400
410
411
420
421
430
431
432
440

510
520

----
목표
n번쨰 감소하는수를 찾는다.
한번에 몇번째 감소하는 수인지 찾기는 어렵다.
규칙성을 알아야만 가능
컴퓨터를 이용해서 하니까
좀더 작은 규칙들을 적용해서 더해가면서 확인한다.
결국 작은 숫자부터 수를 증가시켜가면서 확인

- 10의 n제곱으로 표현
  - 작은 자릿수부터 확인
  - 322
	expo = 1
	prev = -1
    digit = 321 % (10 ** expo)
	if prev >= digit: # 감소하는 수가 아닌 경우
		
		
	321 % (10 ** digit)

전체로직
- n을 감소시키면서 n번째 "감소하는 num"를 찾는다.
- num을 작은 자릿수부터 큰 자릿수까지 확인해간다.
  작은 자릿수부터 시작하므로 "증가하는 수"여야한다.
  다음 증가하는 수가 되기 위한 조건


전체적으로 논리가 맞지 않는 부분이 있음
- 각 자릿수별 연산 while문
- n번째일때 끝나게 했지만  증가하는 부분
  


while (n):	#n이 0이 될때까지
	expo = 1
	prev = -1
	num = 0
	while (num // digit): # 1의 자릿수부터 큰자릿수까지
		

	n -= 1


- 322
1의 자릿수 2
before
	prev = -1
	expo = 1
after
	prev = 2
	expo = 2

10의 자릿수 2
before
	prev = 2
	expo = 2
after
	prev = 2
	expo = 2
	if prev >= digit: 
	# 이 부분에 걸림
	num += 10 ** (expo-1)
	# 하지만 뒤의 자릿수는 다 0으로 만들어야한다.
	다 0으로 만들면 expo가 3이상인 경우
	000 같은 수들이라 이미 감소하는 수가 아니다
	
	- 321
	322
	330
	400
	401
	- 410
	411
	420
	- 420
	- 421
	
123 mod 10 => 3 -> 3 // 10**(expo-1)
123 mod 10**2 => 23  -> 23 // 10**(expo-1)
123 mod 10**3 => 123  -> 123 // 10**(expo-1)
2만 나와야한다.
어떻게 처리할것인가

123 // 10 => 1
123 // 100 => 1

123 mod 1




	
자릿수를 확인하고
앞에서부터 처리한다면?
자릿수 크기를 이전 연산에서 이어받는다.
321
3 2 1

expo = 2
2 1   0
4[3..1][2..0]
4[1][0]
4[2][1..0]
4[3][2..0]
	
	
자릿수별로 가질 수 있는 감소하는 수가 정해진다.
일일이 확인하지 않고 n을 감소시킨 뒤
마지막에 해당 숫자를 return한다?
언제가 끝 지점인지 확인하기 쉽지 않고
연산량에 그다지 이득이 있을거 같지 않아서 
1개씩 확인하는 편이 확실하면서 시간적인 측면에서도 크게 차이나지
않을거 같다.





#검증


#실행


#회고


