기능개발

프로그래머스 팀에서 기능 개선 작업을 수행 중
각 기능은 진도가 100%일 때 서비스에 반영할 수 있다.

각 기능의 개발속도는 모두 다르기 떄문에 뒤에 있는 기능이
앞에 있는 기능보다 먼저 개발될 수 있다. 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 떄 
같이 배포된다.

먼저 배포되어야 하는 순서대로의 작업의 진도가 적힌 쟁수 배열
progresses와 각 작업의 개발속도가 적힌 정수 배열 speeds가 주어질 떄문에
각 배포마다 몇개의 기능이 배포되는지 return


#문제이해
배포는 하루에 1번만 가능 
앞에 기능이 개발완료되어야 뒤에 미리 완성된 기능도 같이 배포될 수 있음
그럴 경우 배포시기마다 몇 개의 기능이 배포되었는지
순차적으로 배열에 담아서 return


#문제해결방법
큐, 스택과의 연관성

앞의 기능이 100퍼가 아닐때 
뒤의 기능   중에 100퍼가 미리 도달되는 경우
별도로 100퍼가 먼저되는 기능을 큐나 스택 등에 담는다면
( 같은 위치에 있는 speeds 배열의 원소 값들도 제거해야함 )
기존 배열의 값들은 앞으로 당겨오게된다
그 경우 별도의 큐에 담겨있는 값들이 완료된 앞의 기능인지 어떻게 알고서 
같이 배포일에 배포되었다고 구분할 것인가? 
해시로 관리한다?

애초에 별도 자료구조(스택, 큐)에 담지 않는다?
배열에 그대로 놔두고서 100이 되게 만들고 
100 미만인 값들만 각자의 개발속도대로 매일 더해주고
앞에서부터 연속적으로 100인 값들만 배열에서 빠지게 만든다?

이 경우 배열에 앞에 인덱스가 빠짐으로인해
뒤에 원소들이 당겨와야한다는 점은 같다.

그렇다면 초기에 배열에 담긴 값들을 연결리스트형 자료구조로 담는다?
이미 배열로 값이 담긴 것을 다른 자료구조로 만들때 
그에 따른 메모리 사용과 소요되는 시간이
이미 배열로 남아있는채로 쓰는 거보다 나을까?

배열로 계속쓰면 입력,삭제마다 계속 위치를 바꿔줘야한다.

- progresses, speeds 모두 queue로 새로 만든다.
- progresses 큐가 빌때까지 반복문을 돌린다.
  - 큐와 일치하는 인덱스의 speeds 값으로 진도가 100 이상이 될때까지 더한다.
  - 100이 넘는 값은 더이상 더하지 않는다.
  - 맨앞의 기능부터 연속적으로 이어진 기능이 100일떄 해당 기능들을 카운트하여 
    answer 배열에 카운트된 값을 추가한다. 카운트된 값들은 progresses, speeds에서 제거한다.
	

하루마다 progresses배열에 각 원소별로 개발속도를 더한다.
100을 넘는 progresses는 



#실행


#반성
- 데이터가 적어서인지는 모르겠지만 있는 배열 그대로 실행했을때나 
deque로 다시 바꾸어 저장할때나 성능차이는 미미함

- 라이브러리 도움없이 할수 있으면 그렇게 구현할 것
- zip등 iterable 데이터를 다루는 메소드에 능숙할 것
- 다중 loop를 안쓰고 구현할수 있도록 단순화할 것

