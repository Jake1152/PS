디스크 컨트롤러  04-06DEC

하드디스크는 한번에 하나의 작업만 수행할 수 있다.
디스크 컨트롤러를 구현하는 방법은 여러가지가 있다.
가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것이다.

예를들어
- 0ms 시점에 3ms가 소요되는 A작업 요청
- 1ms 시점에 9ms가 소요되는 B작업 요청
- 2ms 시점에 6ms가 소요되는 C작업 요청

한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.
- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)
- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)
- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)
이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.

하지만 A → C → B 순서대로 처리하면

- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)
- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)
이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.

각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 
작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. 
(단, 소수점 이하의 수는 버립니다)

제한 사항
jobs의 길이는 1 이상 500 이하입니다.
jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.
입출력 예
jobs	return
[[0, 3], [1, 9], [2, 6]]	9
입출력 예 설명
문제에 주어진 예와 같습니다.

0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.
1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.
2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.



#문제이해
디스크에 할당되는 작업들의 '작업요청부터 작업이 종료될때까지' 소요된 시간의 평균을 가장 작게 되도록 작업 순서를 변경하여 처리하며
최소가 되는 평균시간을 return



#문제해결방법
'작업요청부터 작업이 종료될때까지' 평균이 적을려면 어떻게 해야하나
작업요청으로부터 가급적 빨리 처리한다.
여러 작업이 겹쳐있다.
작업소요시간이 짧은 것부터 처리하면 평균이 짧아질 수 있다.
하지만 작업이 언제 할당 되었는지, 비슷한 시기에 할당된 다른 작업의 소요시간은 어땠는지
그 작업부터 처리한다면 총 처리소요시간은 어떻게 될 것인지

모든 작업의 '작업요청부터 작업이 종료될때까지의 쓰이는 시간'의 총합이 최소가 되게 작업순서를 할당한다.


제일 처음 할당된 작업의 소요시간이 너무 길고 
이후에 더 짧은 작업시간을 가진 작업들이 이른 시간에 할당되었다면 
첫 작업을 바로 처리하지 말고 이후에 할당된 작업들을 먼저처리하는게
모든 작업들의 (대기시간+작업시간)의 총합을 줄일 수 있다.
앞의 작업이 언제 끝나는지, 이후에 할당된 작업이 언제부터 대기했는지를 이용해서 풀 수 있다.

대기시간+작업시간, 이전작업이 끝나는 시간에 따른 예상 종료시간의 가중치를 구한다? 

가중치를 기준으로 heap을 구성 
그런데 가중치를 어떻게 구해야 효율적인가
어떻게 구할 수 있는가?
순서대로 들어온대로 종료시간을 계산하고
앞에 작업이 있다면 앞에 작업이 끝나는 시간부터 다음 작업소요시간을 더한다.
다음 작업이 끝난 시간에서 처음 작업이 할당된 시간을 뺀다.

요청에서 종료까지의 기준

이전 작업이 끝나야 바로 진행이 가능하다.
입국심사 기달리는 것과 비슷 
어떻게해야 최소 시간에 끝나게 할 것인가.
들어오는 문제를 바로 처리할 것인가
기달렸다가 다음에 들어오는 문제를 처리하는게
전체처리소요시간이 감소하게 될 것인가

ex)
1. [0,10],[1,1]

10+10

11+1

들어온지로부터 언제 작업이 할당되는지?

0, 9
11, 0
작업시간까지 감안해야된다.


2. [0,10],[1,8],[2,1]

10+17+17  (10,8,1)
19+8+18   (8,10,1)
1+10+21   (1,8,10)

기준 앞에 작업이 끝나기 전에 들어오는 
작업이 바로 할당된다 가정하고 그 작업이 이전 작업보다
먼저 끝나게 된다고 한다면

앞에 작업을 하지 말고
기달렸다가 다음 작업부터 끝내는게 더 낫다.
하지만 이 경우가 항상 적용되는가?

앞에 작업'들' 보다 먼저 끝나는 것을 기준?
바로 앞의 작업만이 아닌 다른 작업이 끝나는 걸 기준으로하면 어떻게되는가?

만약 4번째 작업을 먼저하는게 유리하다고 가정한다면?
0,10  1,8  2,6  4,3

7초  3
13초 11
21초 20
31초 31
55

8초 6
16초 15
19초 15
29초 29
65

10초 10
18초 17
24초 22
27초 23
72


그렇다면 어디까지 가중치를 측정해야하는가?
현재의 가장 좋은 조건(작업이 끝나게되는 '시점'이 빠른 작업)의 작업이
끝나는 시점보다 더 빨리 작업이 끝나는 작업이 있는지가 기준 
없다면 작업이 끝나는 시점(바로 할당되어서 작업된다고 가정했을때)을 기준으로 
heapify구성
꼭 바로 할당되어 작업하는걸 기준으로해도 다른 모든 경우에도 동일한 결과를 가져올 수 있나?

아래 가장 빠른 작업(계속 흐르는 전체 시간 기준으로 빨리 끝나는 작업)이 
끝난 뒤에 들어오는 작업에 관해서는 기준을 어떻게 잡을 것인가?
바로 할당되는걸 기준으로 작업 종료 시점이 같으면 먼저 들어온 작업부터 처리하게 한다.
0,10  1,8  2,6  4,3(7초에 작업끝)   7,3





앞에 1개의 작업들을 기준?
매 순간에 가장 좋은 기준?
그렇게 가중치를 확인?



- 2차원 배열의 heap

#실행


#반성



