큰 수 만들기 13DEC20 AM 1:41
-이해 2"00
-해결방법 16"00(논리오류발견)+14"00+07"00방식 수정(메모리 덜 쓰도록), 
 37"00(논리오류발견)+30"00 (순회 수정) +8"00
 (팁 참조 이후) 15"00 + 55"00
  
-구현1 10"00(논리오류발견) 3"00(오류발견 중단) 10"00(정확도 90)
-검증 6"00 +
-손코딩 7"00+30"(오류수정)
-구현2 3"00 
-검증 5"00
-디버깅 60"00

Description
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.
문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

제한 조건
number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
k는 1 이상 number의 자릿수 미만인 자연수입니다.

입출력 예
number	k	return
1924	2	94
1231234	3	3234
4177252841	4	775841


#문제이해
어떤 숫자에서 k개의 숫자를 제거하여 얻을 수 있는 가장 큰 숫자
제거만하는 것이므로 숫자들의 상대적 위치는 바뀌지 않는다.
1924, 2개 제거
14, 1924에서 92를 제거했을뿐 1과 4의 위치가 뒤바뀌지는 않는다.
4보다 1이 앞에 있는건 변함없는 사실

#문제해결방법
주어진 숫자에서 k개씩 빼본 다음에 가장 큰 숫자를 반환?
brute force방법이라 일단 다른 방법이 없기까지는 제외

어떻게 지워야 값이 클 것인가?

--첫번째 방법
작은 수를 먼저 지운다?
k개의 수를 number에서 지울때 각 자릿수별로 작은 수를 가장 큰 자릿수부터 지운다.
X 

--두번째 방법
지우지말고 큰 숫자를 answer문자열에 추가한다.

앞에 자리숫자가 가장 크도록 되는게 큰 수가 될 확률이 높음
제일 앞의 자리 숫자가 커야한다.

answer문자열의 길이가 number길이에서 k를 뺀 숫자와 같아질 때까지 반복한다.
if 앞의 자릿수가 뒤의 자릿수보다 크면 앞의 자리수를 answer에 추가한다.
elif 앞의 자릿수와 뒤의 자릿수가 같으면서 남아있는 number의 자릿수의 개수가
answer에 채워야할 개수와 같아지면 앞의 자릿수와 
뒤의 자릿수가 같거나 작은값이더라도 answer에 추가한다.

if문 이후에 인덱스 값 +1

----
각 자릿수별로 작은 수는 어떻게 파악하는게 효율적인가?
자릿수별로 어떤수가 있는지 파악?

작은숫자가 중복일떄
1911, k=2

1, 두 개를 지워야하지만 끝에 2개만 지우면 19가 된다
91이 되는게 가장 큰 값

욕심쟁이 기법은 매 순간 가장 이득이 되는걸 취하는 방식
어떻게 해야 매 순간 가장 이득인가?
작은 사례로 쪼개기

k개수만큼 반복
1씩 숫자를 제거 
어떤 수를 제거했을때 가장 큰가?
99991
99919
789512
1684562
앞에 숫자가 뒤의 숫자보다 작으면 제거?

1684562
684562
84562
8562
862
86
8
number_length = len(number)
while number_length-k < len(number)


k = 4, number = '423666'
423666, i=1, answer=""
423666, i=2, answer="4"
423666, i=3, answer="4"
423666, i=4, answer="4", answer 
423666, i=5, answer="4"

에러 발견
3개 이하만 찾고자하면?
6으로 이루어졌을때가 제일크다.
그러므로 숫자 문자열을 거의 끝까지 순회해야지만 알 수 있다.

k = 3, number = '423666'
expect=9899
4798799, i=1, answer=""
4798799, i=2, answer=""
4798799, i=3, answer="9"
4798799, i=4, answer="98"

--세번째 방법 14DEC PM 4:02
이전 방법 수정 및 answer문자열의 각 자릿수 값과 answer문자열에 추가되어야할 숫자 개수, 
number문자열에 순회해야할 자릿수의 개수를 감안하여 숫자를 answer문자열에 추가할지, 
answer문자열을 초기화 혹은 부분삭제 한 뒤 추가할지를 결정
복잡하지 않은가?
더 단순한 방법은?
읽는거는 앞에서부터 읽을 수밖에 없다.
자릿수의 순서를 바꿀 수 없기 때문.

현재의 순회 방식(i=1번 인덱스부터 시작)
number[i-1] > number[i]
앞의 자릿수가 뒤의 자릿수보다 크면 넣을지를 조건문을 탄다
하지만 마지막번째 숫자인 경우 이 방식으로는 처리되지않는다.
그렇다고 마지막번쨰인지 매번 확인하는건 비효율적이다.
마지막번쨰수 비교는 반복문 밖에서 한다?
그러면 중복되는 루틴(answer문자열과의 비교, answer문자열에 들어가야할 숫자의 개수)이 생긴다.
한번에 읽기에도 쉽고 깔끔하게 만들고 싶다.
어떻게 구조를 만들어야 깔끔하면서도 처리가 가능한가?

greedy 
쪼갤 수 있는 가장 작은 단위들로 문제를 나눈다.
가장 작은 단위들을 문제를 각자 해결하고서
서로 합쳐나아간다.
부분 해의 총합이 전체의 해답이 되게 한다.

이 문제를 쪼개면 어떻게 되는가?
매 순간 가장 큰 수가 되게 할려면 어떤 방법을 써야하는가?
(number문자열 길이 - k)길이의 answer 문자열을 만들어야 한다.
number로 주어진 수의 자릿수를 앞뒤로 바꾸는 일은 없다.
처음에 큰 자릿수였으면 삭제하고 남은 자릿수만 가지고 answer문자열을 구성할 때도 마찬가지이다.
1번에 1개만 비교가능, 
큰 자릿수가 작은 자릿수보다 먼저 answer문자열에 들어가야함 
자릿수의 서열은 계속 유지됨

앞의 자릿수와 뒤의 자릿수 비교해서 앞의 자릿수가 클떄, 서로 같을 때

answer 길이가 1이상이면


앞 자릿수와 뒷 자릿수를 비교하여
앞 자릿수가 더 크고 answer문자열이 비어있으면 추가한다.
answer문자열에 1개라도 들어있으면 
answer문자열의 제일 앞에 인덱스부터 값을 비교하여 
현재 answer문자열의 있는 숫자보다 크면 
뒤에 answer문자열 뒤의 숫자들은 다 삭제하고 
answer배열 남은 숫자열에 비교하던 number 배열의 원소값을 추가한다.
그렇지 않다면(answer문자열 안에 있는 모든 자릿수보다 비교 중이던 number 원소값이 작다면)
answer문자열 맨 뒤에 추가한다.

단, 
answer 문자열 남아있어야할 자릿수 길이와 앞으로 number 배열의 순회해야할 자릿수의 개수를 비교하여 결정한다.
남아있어여할 자릿수와 순회해야할 자릿수의 개수가 같다면 number배열의 현재 순회 중이던 위치부터 끝에 1의 자릿수까지 숫자들을 
answer문자열에 추가한다.

number문자열 너무 길지않으면 몇 개의 수를 뻈을때 가장 클지는 쉽게 보인다
한 눈에 보이기 때문에
하지만 컴퓨터에서는 앞에서부터 뒤에까지 순회해봐야
어떤 자릿수의 어떤 숫자가 들어 있는지 알수 있고
그래서 어떤 수를 answer문자열에 추가해서 클지 작을지를 알 수있다.
number 문자열을 거의 끝까지 혹은 완전히 끝까지 순회해야 k개의 어떤 숫자를 제거했을 떄
가장 클지 알 수 있다.

혹시 끝까지 순회하지 않고 알수 있는 다른 방법이 있는가?

--
다른이의 팁
stack, greedy를 이용하여 풀어라


몇 개를 뺄지
지금 이 순간에 어떤걸 뺴는게 가장 이득일지
이 순간의 기준은?
앞자릿수가 뒤 자릿수보다 크면 이득
앞자리 숫자와 뒷자리 숫자가 같으면?

맨 앞에 수부터 스택에 담는다.
그 다음 수가 스택에 있는 수보다 크면 앞에 숫자를 제거한다.
스택의 순회는 ((number길이 - k) - 현재 스택 길이) < number문자열의 순회가 남은 원소 수
위 조건이 맞는 동안 진행한다.
스택의 마지막까지.
"55559" k=4

(number길이 - k) 조건과 number문자열 순회 조건을 같이 매칭하여
반복문 돌리는 조건

"99912" k=4
이 경우 1개만 남으므로 가장 큰 수인 9만 있으면 된다.
9가 아니라 8이하이면 끝까지 순회해야 알 수 있다.


number	k	return
1924	2	94
1231234	3	3234
4177252841	4	

"1924"  2
stack 1
stack 9
stack 92
stack 94
(앞으로 number 문자열 순회 남은 것 + stack size)가 be_remained_len과 같으면
나머지 숫자들을 전부 뒤에 이어붙인다.

(앞으로 number 문자열 순회 남은 것)
ex) 3개
be_remained_len= 7
stack_size=5
((앞으로 number 문자열 순회 남은 것)+stack size) - be_remained_len 개수만큼
stack 순회 단 스택이 맨 밑바닥까지만 가능


- number 끝까지 순회한다 
- 스택에 있는 값과 비교하여 push
- 스택을 순회하는 기준은 number 순회까지 남은 개수, 현재 스택에 숫자 쌓인 개수,
answer문자열(여기서는 스택)에 남아있어야하는 숫자의 개수 


"19245"  2
be_remained_len = 3
1
9
9
945 

"19245"  3
be_remained_len = 2
1
9
9
"99945"  1
# stack에서 뺄 수 있는 개수
스택 top에 있는 수와 number 원소값과 비교해서
number 원소값이 더 크면 스택top에 있는 값을 빼고 
number 원소값을 넣는다.

- num_len = len(number)
- be_remained_len = num_len -k 
- num_stack = [ number[0] ]
- i=1
- while(i < num_len):
num_stack size 비교 
((앞으로 number 문자열 순회 남은 것)+stack size) - be_remained_len 
num_len - i + len(num_stack) > be_remained_len
stack 순회는 최대 stack 길이만큼만 가능 

stack에 있는 숫자들을 최대 몇 개까지 비교할 수 있는가?

"9876556879" 10개 중 4개 제거 6개 남길 수


stack = [9]

순회 9, stack 1, remain_len 6
9>=8
98
순회 8, stack 2, remain_len 6
8>=7
987
순회 7, stack 3, remain_len 6
7>=6
9876
순회 6, stack 4, remain_len 6
6>=5
98765
순회 5, stack 5, remain_len 6
5>=5 
987655
순회 4, stack 6, remain_len 6
5>=6 X 
98765
5>=6 X 
98766
순회 3, stack 5, remain_len 6
순회+stack size - remain_len = 2
최대 2개의 stack top과 비교 연산가능
(현재 순회 중인 위치의 number element가 stack top값보다 크다면)
if stack size <= 순회+stack size - remain_len 
  max_loop_times = stack size
else:
  max_loop_times = 순회+stack size - remain_len 
6>=8 X
9876
6>=8 X
9878
--
98796
6>=8
9879

6>=8

--


순회 2, stack 4, remain_len 6
순회 남은 횟수 + stack size = remain_len

9878+number[i:]

if 순회 남은 횟수 + stack size 
  for loop
  if stack top > number_element
    stack += number_element



#실행
좀만하면 될거같아서 하다보니 되긴되었지만
누더기 같은 코드가 완성되었고 깔끔하지 않다.
버그를 내포할 가능성이 높다.

#반성
- 괜찮은 접근이 안떠오르면 바로 힌트를 찾아본다.
  - 그래도 안되면 다른사람 답을 참고한다.
  - 다른 사람 코드 참고시 완전한 이해 및 응용을 전제로한다.
  손코딩 및 다른 식으로 변경하여 더 효율적으로 구성해본다.
- 구조를 단순하게
  - 해결과정에서 겹치는 부분 소거할 것 
- 문제의 핵심의 내 언어로 재정의
- 이산수학 이해 부족 
  다른이는 비둘기 집을 떠올렸지만 방법을 듣고도 어떻게 적용한건지 안떠오름








