큰 수 만들기 13DEC20 AM 1:41
-이해 2"00
-해결방법 16"00(논리오류발견)+14"00+07"00방식 수정(메모리 덜 쓰도록), 37"00(논리오류발견)+30"00 (순회 수정)
-구현1 10"00(논리오류발견)
-검증 6"00 +
-손코딩 7"00+
-구현2 3"00 
-검증 5"00

Description
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.
문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

제한 조건
number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
k는 1 이상 number의 자릿수 미만인 자연수입니다.

입출력 예
number	k	return
1924	2	94
1231234	3	3234
4177252841	4	775841


#문제이해
어떤 숫자에서 k개의 숫자를 제거하여 얻을 수 있는 가장 큰 숫자
제거만하는 것이므로 숫자들의 상대적 위치는 바뀌지 않는다.
1924, 2개 제거
14, 1924에서 92를 제거했을뿐 1과 4의 위치가 뒤바뀌지는 않는다.
4보다 1이 앞에 있는건 변함없는 사실

#문제해결방법
주어진 숫자에서 k개씩 빼본 다음에 가장 큰 숫자를 반환?
brute force방법이라 일단 다른 방법이 없기까지는 제외

어떻게 지워야 값이 클 것인가?

--첫번째 방법
작은 수를 먼저 지운다?
k개의 수를 number에서 지울때 각 자릿수별로 작은 수를 가장 큰 자릿수부터 지운다.
X 

--두번째 방법
지우지말고 큰 숫자를 answer문자열에 추가한다.

앞에 자리숫자가 가장 크도록 되는게 큰 수가 될 확률이 높음
제일 앞의 자리 숫자가 커야한다.

answer문자열의 길이가 number길이에서 k를 뺀 숫자와 같아질 때까지 반복한다.
if 앞의 자릿수가 뒤의 자릿수보다 크면 앞의 자리수를 answer에 추가한다.
elif 앞의 자릿수와 뒤의 자릿수가 같으면서 남아있는 number의 자릿수의 개수가
answer에 채워야할 개수와 같아지면 앞의 자릿수와 
뒤의 자릿수가 같거나 작은값이더라도 answer에 추가한다.

if문 이후에 인덱스 값 +1

----
각 자릿수별로 작은 수는 어떻게 파악하는게 효율적인가?
자릿수별로 어떤수가 있는지 파악?

작은숫자가 중복일떄
1911, k=2

1, 두 개를 지워야하지만 끝에 2개만 지우면 19가 된다
91이 되는게 가장 큰 값

욕심쟁이 기법은 매 순간 가장 이득이 되는걸 취하는 방식
어떻게 해야 매 순간 가장 이득인가?
작은 사례로 쪼개기

k개수만큼 반복
1씩 숫자를 제거 
어떤 수를 제거했을때 가장 큰가?
99991
99919
789512
1684562
앞에 숫자가 뒤의 숫자보다 작으면 제거?

1684562
684562
84562
8562
862
86
8
number_length = len(number)
while number_length-k < len(number)


k = 4, number = '423666'
423666, i=1, answer=""
423666, i=2, answer="4"
423666, i=3, answer="4"
423666, i=4, answer="4", answer 
423666, i=5, answer="4"

에러 발견
3개 이하만 찾고자하면?
6으로 이루어졌을때가 제일크다.
그러므로 숫자 문자열을 거의 끝까지 순회해야지만 알 수 있다.

k = 3, number = '423666'
expect=9899
4798799, i=1, answer=""
4798799, i=2, answer=""
4798799, i=3, answer="9"
4798799, i=4, answer="98"

--세번쨰 방법 14DEC PM 4:02
이전 방법 수정 및 answer문자열의 각 자릿수 값과 answer문자열에 추가되어야할 숫자 개수, 
number문자열에 순회해야할 자릿수의 개수를 감안하여 숫자를 answer문자열에 추가할지, 
answer문자열을 초기화 혹은 부분삭제 한 뒤 추가할지를 결정
복잡하지 않은가?
더 단순한 방법은?
읽는거는 앞에서부터 읽을 수밖에 없다.
자릿수의 순서를 바꿀 수 없기 때문.

현재의 순회 방식(i=1번 인덱스부터 시작)
number[i-1] > number[i]
앞의 자릿수가 뒤의 자릿수보다 크면 넣을지를 조건문을 탄다
하지만 마지막번째 숫자인 경우 이 방식으로는 처리되지않는다.
그렇다고 마지막번쨰인지 매번 확인하는건 비효율적이다.
마지막번쨰수 비교는 반복문 밖에서 한다?
그러면 중복되는 루틴(answer문자열과의 비교, answer문자열에 들어가야할 숫자의 개수)이 생긴다.
한번에 읽기에도 쉽고 깔끔하게 만들고 싶다.
어떻게 구조를 만들어야 깔끔하면서도 처리가 가능한가?

greedy 
쪼개를 수 있는 가장 작은 단위들로 문제를 나눈다.
가장 작은 단위들을 문제를 각자 해결하고서
서로 합쳐나아간다.
부분 해의 총합이 전체의 해답이 되게 한다.

이 문제를 쪼개면 어떻게 되는가?
매 순간 가장 큰 수가 되게 할려면 어떤 방법을 써야하는가?
(number문자열 길이 - k)길이의 answer 문자열을 만들어야 한다.
number로 주어진 수의 자릿수를 앞뒤로 바꾸는 일은 없다.
처음에 큰 자릿수였으면 삭제하고 남은 자릿수만 가지고 answer문자열을 구성할 때도 마찬가지이다.
1번에 1개만 비교가능, 
큰 자릿수가 작은 자릿수보다 먼저 answer문자열에 들어가야함 
자릿수의 서열은 계속 유지됨

앞의 자릿수와 뒤의 자릿수 비교해서 앞의 자릿수가 클떄, 서로 같을 때



answer 길이가 1이상이면





앞 자릿수와 뒷 자릿수를 비교하여
앞 자릿수가 더 크고 answer문자열이 비어있으면 추가한다.
answer문자열에 1개라도 들어있으면 
answer문자열의 제일 앞에 인덱스부터 값을 비교하여 
현재 answer문자열의 있는 숫자보다 크면 
뒤에 answer문자열 뒤의 숫자들은 다 삭제하고 
answer배열 남은 숫자열에 비교하던 number 배열의 원소값을 추가한다.
그렇지 않다면(answer문자열 안에 있는 모든 자릿수보다 비교 중이던 number 원소값이 작다면)
answer문자열 맨 뒤에 추가한다.

단, 
answer 문자열 남아있어야할 자릿수 길이와 앞으로 number 배열의 순회해야할 자릿수의 개수를 비교하여 결정한다.
남아있어여할 자릿수와 순회해야할 자릿수의 개수가 같다면 number배열의 현재 순회 중이던 위치부터 끝에 1의 자릿수까지 숫자들을 
answer문자열에 추가한다.

number문자열 너무 길지않으면 몇 개의 수를 뻈을때 가장 클지는 쉽게 보인다
한 눈에 보이기 때문에
하지만 컴퓨터에서는 앞에서부터 뒤에까지 순회해봐야
어떤 자릿수의 어떤 숫자가 들어 있는지 알수 있고
그래서 어떤 수를 answer문자열에 추가해서 클지 작을지를 알 수있다.
number 문자열을 거의 끝까지 혹은 완전히 끝까지 순회해야 k개의 어떤 숫자를 제거했을 떄
가장 클지 알 수 있다.

혹시 끝까지 순회하지 않고 알수 있는 다른 방법이 있는가?


number	k	return
4177252841	4	775841













